String.prototype.rightChars = function(n) {
    if (n <= 0) {
        return "";
    } else if (n > this.length) {
        return this;
    } else {
        return this.substring(this.length, this.length - n);
    }
};

(function($) {
    var options = {
        highlightSpeed: 20,
        typeSpeed: 100,
        clearDelay: 500,
        typeDelay: 200,
        clearOnHighlight: true,
        typerDataAttr: "data-typer-targets",
        typerInterval: 1500,
        highlightColor: "#999999",
        textColor: "#fafafa",
        initialDelay: 300
    }, highlight, clearText, backspace, type, spanWithColor, clearDelay, typeDelay, clearData, isNumber, typeWithAttribute, getHighlightInterval, getTypeInterval, typerInterval;
    spanWithColor = function(color, backgroundColor) {
        if (color === "rgba(0, 0, 0, 0)") {
            color = "rgb(255, 255, 255)";
        }
        return $("<span></span>").css("color", color).css("background-color", backgroundColor);
    };
    isNumber = function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    };
    clearData = function($e) {
        $e.removeData([ "typePosition", "highlightPosition", "leftStop", "rightStop", "primaryColor", "backgroundColor", "text", "typing" ]);
    };
    type = function($e) {
        var text = $e.data("text"), oldLeft = $e.data("oldLeft"), oldRight = $e.data("oldRight");
        if (!text || text.length === 0) {
            clearData($e);
            return;
        }
        $e.text(oldLeft + text.charAt(0) + oldRight).data({
            oldLeft: oldLeft + text.charAt(0),
            text: text.substring(1)
        });
        setTimeout(function() {
            type($e);
        }, getTypeInterval());
    };
    clearText = function($e) {
        $e.find("span").remove();
        setTimeout(function() {
            type($e);
        }, typeDelay());
    };
    highlight = function($e) {
        var position = $e.data("highlightPosition"), leftText, highlightedText, rightText;
        if (!isNumber(position)) {
            position = $e.data("rightStop") + 1;
        }
        if (position <= $e.data("leftStop")) {
            setTimeout(function() {
                clearText($e);
            }, clearDelay());
            return;
        }
        leftText = $e.text().substring(0, position - 1);
        highlightedText = $e.text().substring(position - 1, $e.data("rightStop") + 1);
        rightText = $e.text().substring($e.data("rightStop") + 1);
        $e.html(leftText).append(spanWithColor($e.data("backgroundColor"), $e.data("primaryColor")).append(highlightedText)).append(rightText);
        $e.data("highlightPosition", position - 1);
        setTimeout(function() {
            return highlight($e);
        }, getHighlightInterval());
    };
    typeWithAttribute = function($e) {
        var targets;
        if ($e.data("typing")) {
            return;
        }
        try {
            targets = JSON.parse($e.attr($.typer.options.typerDataAttr)).targets;
        } catch (e) {}
        if (typeof targets === "undefined") {
            targets = $.map($e.attr($.typer.options.typerDataAttr).split(","), function(e) {
                return $.trim(e);
            });
        }
        $e.typeTo(targets[Math.floor(Math.random() * targets.length)]);
    };
    $.typer = function() {
        return {
            options: options
        };
    }();
    $.extend($.typer, {
        options: options
    });
    $.fn.typer = function() {
        var $elements = $(this);
        return $elements.each(function() {
            var $e = $(this);
            if (typeof $e.attr($.typer.options.typerDataAttr) === "undefined") {
                return;
            }
            typeWithAttribute($e);
            setInterval(function() {
                typeWithAttribute($e);
            }, typerInterval());
        });
    };
    $.fn.typeTo = function(newString) {
        var $e = $(this), currentText = $e.text(), i = 0, j = 0;
        if (currentText === newString) {
            console.log("Our strings our equal, nothing to type");
            return $e;
        }
        if (currentText !== $e.html()) {
            console.error("Typer does not work on elements with child elements.");
            return $e;
        }
        $e.data("typing", true);
        while (currentText.charAt(i) === newString.charAt(i)) {
            i++;
        }
        while (currentText.rightChars(j) === newString.rightChars(j)) {
            j++;
        }
        newString = newString.substring(i, newString.length - j + 1);
        $e.data({
            oldLeft: currentText.substring(0, i),
            oldRight: currentText.rightChars(j - 1),
            leftStop: i,
            rightStop: currentText.length - j,
            primaryColor: $.typer.options.highlightColor || $e.css("color"),
            backgroundColor: $.typer.options.textColor || $e.css("background-color"),
            text: newString
        });
        var initDelay = function() {
            highlight($e);
            return $e;
        };
        window.setTimeout(initDelay, $.typer.options.initialDelay);
    };
    getHighlightInterval = function() {
        return $.typer.options.highlightSpeed;
    };
    getTypeInterval = function() {
        return $.typer.options.typeSpeed;
    }, clearDelay = function() {
        return $.typer.options.clearDelay;
    }, typeDelay = function() {
        return $.typer.options.typeDelay;
    };
    typerInterval = function() {
        return $.typer.options.typerInterval;
    };
})(jQuery);

(function($, window, undefined) {
    "use strict";
    $.HoverDir = function(options, element) {
        this.$el = $(element);
        this._init(options);
    };
    $.HoverDir.defaults = {
        speed: 300,
        easing: "ease",
        hoverDelay: 0,
        inverse: false
    };
    $.HoverDir.prototype = {
        _init: function(options) {
            this.options = $.extend(true, {}, $.HoverDir.defaults, options);
            this.transitionProp = "all " + this.options.speed + "ms " + this.options.easing;
            this.support = Modernizr.csstransitions;
            this._loadEvents();
        },
        _loadEvents: function() {
            var self = this;
            this.$el.on("mouseenter.hoverdir, mouseleave.hoverdir", function(event) {
                var $el = $(this), $hoverElem = $el.find("div"), direction = self._getDir($el, {
                    x: event.pageX,
                    y: event.pageY
                }), styleCSS = self._getStyle(direction);
                if (event.type === "mouseenter") {
                    $hoverElem.hide().css(styleCSS.from);
                    clearTimeout(self.tmhover);
                    self.tmhover = setTimeout(function() {
                        $hoverElem.show(0, function() {
                            var $el = $(this);
                            if (self.support) {
                                $el.css("transition", self.transitionProp);
                            }
                            self._applyAnimation($el, styleCSS.to, self.options.speed);
                        });
                    }, self.options.hoverDelay);
                } else {
                    if (self.support) {
                        $hoverElem.css("transition", self.transitionProp);
                    }
                    clearTimeout(self.tmhover);
                    self._applyAnimation($hoverElem, styleCSS.from, self.options.speed);
                }
            });
        },
        _getDir: function($el, coordinates) {
            var w = $el.width(), h = $el.height(), x = (coordinates.x - $el.offset().left - w / 2) * (w > h ? h / w : 1), y = (coordinates.y - $el.offset().top - h / 2) * (h > w ? w / h : 1), direction = Math.round((Math.atan2(y, x) * (180 / Math.PI) + 180) / 90 + 3) % 4;
            return direction;
        },
        _getStyle: function(direction) {
            var fromStyle, toStyle, slideFromTop = {
                left: "0px",
                top: "-100%"
            }, slideFromBottom = {
                left: "0px",
                top: "100%"
            }, slideFromLeft = {
                left: "-100%",
                top: "0px"
            }, slideFromRight = {
                left: "100%",
                top: "0px"
            }, slideTop = {
                top: "0px"
            }, slideLeft = {
                left: "0px"
            };
            switch (direction) {
              case 0:
                fromStyle = !this.options.inverse ? slideFromTop : slideFromBottom;
                toStyle = slideTop;
                break;

              case 1:
                fromStyle = !this.options.inverse ? slideFromRight : slideFromLeft;
                toStyle = slideLeft;
                break;

              case 2:
                fromStyle = !this.options.inverse ? slideFromBottom : slideFromTop;
                toStyle = slideTop;
                break;

              case 3:
                fromStyle = !this.options.inverse ? slideFromLeft : slideFromRight;
                toStyle = slideLeft;
                break;
            }
            return {
                from: fromStyle,
                to: toStyle
            };
        },
        _applyAnimation: function(el, styleCSS, speed) {
            $.fn.applyStyle = this.support ? $.fn.css : $.fn.animate;
            el.stop().applyStyle(styleCSS, $.extend(true, [], {
                duration: speed + "ms"
            }));
        }
    };
    var logError = function(message) {
        if (window.console) {
            window.console.error(message);
        }
    };
    $.fn.hoverdir = function(options) {
        var instance = $.data(this, "hoverdir");
        if (typeof options === "string") {
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function() {
                if (!instance) {
                    logError("cannot call methods on hoverdir prior to initialization; " + "attempted to call method '" + options + "'");
                    return;
                }
                if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                    logError("no such method '" + options + "' for hoverdir instance");
                    return;
                }
                instance[options].apply(instance, args);
            });
        } else {
            this.each(function() {
                if (instance) {
                    instance._init();
                } else {
                    instance = $.data(this, "hoverdir", new $.HoverDir(options, this));
                }
            });
        }
        return instance;
    };
})(jQuery, window);

!function(a, b) {
    "use strict";
    function c(a) {
        this.callback = a, this.ticking = !1;
    }
    function d(b) {
        return b && "undefined" != typeof a && (b === a || b.nodeType);
    }
    function e(a) {
        if (arguments.length <= 0) throw new Error("Missing arguments in extend function");
        var b, c, f = a || {};
        for (c = 1; c < arguments.length; c++) {
            var g = arguments[c] || {};
            for (b in g) f[b] = "object" != typeof f[b] || d(f[b]) ? f[b] || g[b] : e(f[b], g[b]);
        }
        return f;
    }
    function f(a) {
        return a === Object(a) ? a : {
            down: a,
            up: a
        };
    }
    function g(a, b) {
        b = e(b, g.options), this.lastKnownScrollY = 0, this.elem = a, this.debouncer = new c(this.update.bind(this)), 
        this.tolerance = f(b.tolerance), this.classes = b.classes, this.offset = b.offset, 
        this.scroller = b.scroller, this.initialised = !1, this.onPin = b.onPin, this.onUnpin = b.onUnpin, 
        this.onTop = b.onTop, this.onNotTop = b.onNotTop;
    }
    var h = {
        bind: !!function() {}.bind,
        classList: "classList" in b.documentElement,
        rAF: !!(a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame)
    };
    a.requestAnimationFrame = a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame, 
    c.prototype = {
        constructor: c,
        update: function() {
            this.callback && this.callback(), this.ticking = !1;
        },
        requestTick: function() {
            this.ticking || (requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this))), 
            this.ticking = !0);
        },
        handleEvent: function() {
            this.requestTick();
        }
    }, g.prototype = {
        constructor: g,
        init: function() {
            return g.cutsTheMustard ? (this.elem.classList.add(this.classes.initial), setTimeout(this.attachEvent.bind(this), 100), 
            this) : void 0;
        },
        destroy: function() {
            var a = this.classes;
            this.initialised = !1, this.elem.classList.remove(a.unpinned, a.pinned, a.top, a.initial), 
            this.scroller.removeEventListener("scroll", this.debouncer, !1);
        },
        attachEvent: function() {
            this.initialised || (this.lastKnownScrollY = this.getScrollY(), this.initialised = !0, 
            this.scroller.addEventListener("scroll", this.debouncer, !1), this.debouncer.handleEvent());
        },
        unpin: function() {
            var a = this.elem.classList, b = this.classes;
            (a.contains(b.pinned) || !a.contains(b.unpinned)) && (a.add(b.unpinned), a.remove(b.pinned), 
            this.onUnpin && this.onUnpin.call(this));
        },
        pin: function() {
            var a = this.elem.classList, b = this.classes;
            a.contains(b.unpinned) && (a.remove(b.unpinned), a.add(b.pinned), this.onPin && this.onPin.call(this));
        },
        top: function() {
            var a = this.elem.classList, b = this.classes;
            a.contains(b.top) || (a.add(b.top), a.remove(b.notTop), this.onTop && this.onTop.call(this));
        },
        notTop: function() {
            var a = this.elem.classList, b = this.classes;
            a.contains(b.notTop) || (a.add(b.notTop), a.remove(b.top), this.onNotTop && this.onNotTop.call(this));
        },
        getScrollY: function() {
            return void 0 !== this.scroller.pageYOffset ? this.scroller.pageYOffset : void 0 !== this.scroller.scrollTop ? this.scroller.scrollTop : (b.documentElement || b.body.parentNode || b.body).scrollTop;
        },
        getViewportHeight: function() {
            return a.innerHeight || b.documentElement.clientHeight || b.body.clientHeight;
        },
        getDocumentHeight: function() {
            var a = b.body, c = b.documentElement;
            return Math.max(a.scrollHeight, c.scrollHeight, a.offsetHeight, c.offsetHeight, a.clientHeight, c.clientHeight);
        },
        getElementHeight: function(a) {
            return Math.max(a.scrollHeight, a.offsetHeight, a.clientHeight);
        },
        getScrollerHeight: function() {
            return this.scroller === a || this.scroller === b.body ? this.getDocumentHeight() : this.getElementHeight(this.scroller);
        },
        isOutOfBounds: function(a) {
            var b = 0 > a, c = a + this.getViewportHeight() > this.getScrollerHeight();
            return b || c;
        },
        toleranceExceeded: function(a, b) {
            return Math.abs(a - this.lastKnownScrollY) >= this.tolerance[b];
        },
        shouldUnpin: function(a, b) {
            var c = a > this.lastKnownScrollY, d = a >= this.offset;
            return c && d && b;
        },
        shouldPin: function(a, b) {
            var c = a < this.lastKnownScrollY, d = a <= this.offset;
            return c && b || d;
        },
        update: function() {
            var a = this.getScrollY(), b = a > this.lastKnownScrollY ? "down" : "up", c = this.toleranceExceeded(a, b);
            this.isOutOfBounds(a) || (a <= this.offset ? this.top() : this.notTop(), this.shouldUnpin(a, c) ? this.unpin() : this.shouldPin(a, c) && this.pin(), 
            this.lastKnownScrollY = a);
        }
    }, g.options = {
        tolerance: {
            up: 0,
            down: 0
        },
        offset: 0,
        scroller: a,
        classes: {
            pinned: "headroom--pinned",
            unpinned: "headroom--unpinned",
            top: "headroom--top",
            notTop: "headroom--not-top",
            initial: "headroom"
        }
    }, g.cutsTheMustard = "undefined" != typeof h && h.rAF && h.bind && h.classList, 
    a.Headroom = g;
}(window, document);